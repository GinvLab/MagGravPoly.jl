<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home - MagGravPoly · MagGravPoly.jl</title><meta name="title" content="Home - MagGravPoly · MagGravPoly.jl"/><meta property="og:title" content="Home - MagGravPoly · MagGravPoly.jl"/><meta property="twitter:title" content="Home - MagGravPoly · MagGravPoly.jl"/><meta name="description" content="Documentation for MagGravPoly.jl."/><meta property="og:description" content="Documentation for MagGravPoly.jl."/><meta property="twitter:description" content="Documentation for MagGravPoly.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MagGravPoly.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home - MagGravPoly</a><ul class="internal"><li><a class="tocitem" href="#User-Guide"><span>User Guide</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Theoretical-Background"><span>Theoretical Background</span></a></li><li><a class="tocitem" href="#Tutorial-for-magnetic-calculations"><span>Tutorial for magnetic calculations</span></a></li><li><a class="tocitem" href="#Tutorial-for-gravity-calculations"><span>Tutorial for gravity calculations</span></a></li><li><a class="tocitem" href="#Tutorial-for-joint-mag-and-grav"><span>Tutorial for joint mag and grav</span></a></li><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li></ul></li><li><a class="tocitem" href="geopoly/">GeoPoly</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home - MagGravPoly</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home - MagGravPoly</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GinvLab/MagGravPoly.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GinvLab/MagGravPoly.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MagGravPoly"><a class="docs-heading-anchor" href="#MagGravPoly">MagGravPoly</a><a id="MagGravPoly-1"></a><a class="docs-heading-anchor-permalink" href="#MagGravPoly" title="Permalink"></a></h1><ul><li><a href="#MagGravPoly">MagGravPoly</a></li><li class="no-marker"><ul><li><a href="#User-Guide">User Guide</a></li><li><a href="#Installation">Installation</a></li><li><a href="#Theoretical-Background">Theoretical Background</a></li><li class="no-marker"><ul><li><a href="#Forward-calculation">Forward calculation</a></li><li><a href="#Inverse-calculations">Inverse calculations</a></li></ul></li><li><a href="#Tutorial-for-magnetic-calculations">Tutorial for magnetic calculations</a></li><li><a href="#Tutorial-for-gravity-calculations">Tutorial for gravity calculations</a></li><li><a href="#Tutorial-for-joint-mag-and-grav">Tutorial for joint mag and grav</a></li><li><a href="#Public-API">Public API</a></li><li class="no-marker"><ul><li><a href="#Module">Module</a></li><li><a href="#Data-structures">Data structures</a></li><li><a href="#Forward-functions">Forward functions</a></li><li><a href="#HMC-helper-functions">HMC helper functions</a></li><li><a href="#Misfit-structure-and-functions">Misfit structure &amp; functions</a></li><li><a href="#Useful-functions-for-magnetics">Useful functions for magnetics</a></li></ul></li></ul></li><li><a href="geopoly/#GeoPoly">GeoPoly</a></li><li class="no-marker"><ul><li><a href="geopoly/#User-guide">User guide</a></li><li class="no-marker"><ul><li><a href="geopoly/#Tutorial">Tutorial</a></li></ul></li><li><a href="geopoly/#Public-API">Public API</a></li><li class="no-marker"><ul><li><a href="geopoly/#Data-structures">Data structures</a></li><li><a href="geopoly/#Checking-geometries-functions">Checking-geometries functions</a></li><li><a href="geopoly/#Useful-functions">Useful functions</a></li></ul></li></ul></li></ul><h2 id="User-Guide"><a class="docs-heading-anchor" href="#User-Guide">User Guide</a><a id="User-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#User-Guide" title="Permalink"></a></h2><p><strong>MagGravPoly</strong> is a Julia package to perform magnetic and gravity anomaly calculations using a 2D or 2.75D parameterization in terms of polygons with uniform arbitrary magnetizations and density contrasts. It provides functions to 1) solve the forward problem, 2) calculate the gradient of a given misfit function and 3) create/manage polygonal structures through the internal sub-package <a href="geopoly/#geopoly"><code>GeoPoly</code></a>. Such functions can be used to solve inverse problems both in the deterministic and probabilistic approach. In particular, this package provides some functions to solve inverse problems using the Hamiltonian Monte Carlo (HMC) method, as part of the <a href="https://ginvlab.github.io"><code>GinvLab</code></a> project (see the  <a href="https://github.com/GinvLab/InverseAlgos.jl"><code>InverseAlgos.jl</code></a> package). Gradients are calculated using the technique of automatic differentiation. With this package it is also possible to perform joint magnetic and gravity forward and gradient calculations and hence solve joint inverse problems, see the tutorials below.</p><p>The forward problem formulations for the magnetic case implemented in this package are the following:</p><ul><li>2D case: Talwani &amp; Heirtzler (1962, 1964), Won &amp; Bevis (1987) and revised Kravchinsky, Hnatyshin, Lysak, &amp; Alemie (2019);</li><li>2.75D case: revised Rasmussen &amp; Pedersen (1979) and Campbell (1983).</li></ul><p>The forward problem formulations for the gravity case implemented in this package are the following:</p><ul><li><p>2D case: Talwani, Worzel, &amp; Landisman (1959), with background theory derived from the paper of Hubbert (1948);</p></li><li><p>2.75D case:  Rasmussen &amp; Pedersen (1979).</p></li></ul><p>If you use this code for research or else, please cite the related papers:</p><ul><li><p>Ghirotto, Zunino, Armadillo, &amp; Mosegaard (2021). <strong>Magnetic Anomalies Caused by 2D Polygonal Structures with Uniform Arbitrary Polarization: new insights from analytical/numerical comparison among available algorithm formulations</strong>. <em>Geophysical Research Letters, 48</em>(7), e2020GL091732, https://doi.org/10.1029/2020GL091732.</p></li><li><p>Zunino, Ghirotto, Armadillo, &amp; Fichtner (2022). <strong>Hamiltonian Monte Carlo probabilistic joint inversion of 2D (2.75D) gravity and magnetic data</strong>. <em>Geophysical Research Letters</em>,  49, e2022GL099789. https://doi.org/10.1029/2022GL099789.</p></li></ul><p>Regarding solving the inverse problem with the HMC method, please see the following paper and check out the package <code>InverseAlgos</code>:</p><ul><li>Zunino, Gebraad, Ghirotto, &amp; Fichtner (2023). <strong>HMCLab: a framework for solving diverse geophysical inverse problems using the Hamiltonian Monte Carlo method</strong>. <em>Geophysical Journal International</em>, 235(3), 2979-2991. https://doi.org/10.1093/gji/ggad403.</li></ul><p>In addition, a tutorial about the use of forward formulations and the basic tuning strategies for HMC inversion is presented in detail in the below section.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>To install the package first enter into the package manager mode in Julia by typing &quot;<code>]</code>&quot; at the  REPL prompt and add the &quot;JuliaGeoph&quot; registry as</p><pre><code class="nohighlight hljs">(@v1.9) pkg&gt; registry add https://github.com/GinvLab/GinvLabRegistry</code></pre><p>Then add the package by simply issuing</p><pre><code class="nohighlight hljs">(@v1.9) pkg&gt; add MagGravPoly</code></pre><p>The package will be automatically downloaded from the web and installed.</p><h2 id="Theoretical-Background"><a class="docs-heading-anchor" href="#Theoretical-Background">Theoretical Background</a><a id="Theoretical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-Background" title="Permalink"></a></h2><h3 id="Forward-calculation"><a class="docs-heading-anchor" href="#Forward-calculation">Forward calculation</a><a id="Forward-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-calculation" title="Permalink"></a></h3><p>For a theoretical explanation, let us consider a three-dimensional non-magnetic and zero-density space in which a body infinitely extended in the <span>$y$</span> direction is immersed. </p><p>The common aim of all formulations is the calculation of the total-field magnetic intensity response and vertical attraction of this body upon an observation point <span>$(x_0,z_0)$</span> located along a profile aligned to the <span>$x$</span> direction (the positive <span>$z$</span> axis is assumed pointing downward).</p><p>The starting assumption is that our body can be considered as discretized by an  infinite number of elementary volumes with uniform magnetizazion and density contrast and infinitesimal dimensions <span>$dx$</span>, <span>$dy$</span>, <span>$dz$</span>.</p><p>Within this assumption, the magnetic and gravity fields associated to the body can be mathematically  expressed in terms of a line integral around its periphery, represented in two dimensions  as its polygonal cross-section (in red). <img src="images/intro.svg" alt/></p><h3 id="Inverse-calculations"><a class="docs-heading-anchor" href="#Inverse-calculations">Inverse calculations</a><a id="Inverse-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse-calculations" title="Permalink"></a></h3><p>See the related papers and examples for inverse calculations using the HMC strategy.</p><h2 id="Tutorial-for-magnetic-calculations"><a class="docs-heading-anchor" href="#Tutorial-for-magnetic-calculations">Tutorial for magnetic calculations</a><a id="Tutorial-for-magnetic-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-for-magnetic-calculations" title="Permalink"></a></h2><p>First load the module,</p><pre><code class="language-julia hljs">using MagGravPoly.MG2D</code></pre><p>then define an array containing the location of the observation points, where the first column represents the <span>$x$</span> position and the second the  <span>$z$</span> position. Remark: <span>$z$</span> points <em>downward</em>! So the observations have a negative <span>$z$</span> in this case.</p><pre><code class="language-julia hljs"># number of observations
N=101
xzobs = [LinRange(0.0,120.0,N) -1.0*ones(N)]</code></pre><p>In order to describe the polygonal bodies, two objects need to be specifies: 1)  an array containing all the positions of the vertices (first column represents the <span>$x$</span> position and the second the  <span>$z$</span> position) and 2) a mapping relating each polygonal body to its vertices. The position of vertices <em>must</em> be specifyied in a <strong>counterclockwise</strong> order.</p><pre><code class="language-julia hljs"># vertices of the poligonal bodies
vertices  = [35.0 50.0;
             65.0 50.0;
             80.0 35.0;
             65.0 20.0;
             35.0 20.0;
             20.0 35.0;
             90.0 60.0;
             95.0 40.0]

# indices of vertices for the first polygon
ind1 = collect(1:6)
# indices of vertices for the second polygon
ind2 = [2,7,8,3]
# define the two bodies in term of indices
bodyindices = [ind1,ind2]</code></pre><p>Now, we specify the magnetic properties for each of the polygonal bodies and the angle of the reference system with the north axis:</p><pre><code class="language-julia hljs"># induced magnetization
Jind = MagnetizVector(mod=[4.9,3.5],Ideg=[0.0,0.0],Ddeg=[5.0,5.0])
# remanent magnetization
Jrem = MagnetizVector(mod=[3.1,2.5],Ideg=[45.0,30.0],Ddeg=[0.0,10.0])

# angle with the North axis
northxax = 90.0</code></pre><p>Finally, construct the  poligonal body object by instantiating a <code>MagPolygBodies2D</code> structure. Here we can determine the type of forward calculation, i.e., 2D, 2.5D or 2.75D by specifying the variable <code>ylatext</code>. There are three cases:</p><ol><li>if <code>ylatext=nothing</code> then the polygonal bodies are considered to be extending laterally to infinity, hence a pure 2D forward calculation</li><li>if <code>ylatext</code> is a single real number, then the forward computation is 2.5D, i.e., the polygonal bodies extend laterally on both sides by an amount specified by the value of <code>ylatext</code></li><li>if <code>ylatext</code> is a two-element vector, then the forward computation is 2.75D, i.e., the polygonal bodies extend laterally from <code>ylatext[1]</code> to <code>ylatex[2]</code> (with the condition <code>ylatex[2]&gt;ylatex[1]</code>). </li></ol><p>Here we choose to run a 2.75D forward computation:</p><pre><code class="language-julia hljs">pbody = MagPolygBodies2D(bodyindices,vertices,Jind,Jrem,ylatext=[50.0,90.0])</code></pre><p>At this point the magnetic field can be computed:</p><pre><code class="language-julia hljs">tmag = tmagpolybodies2D(xzobs,northxax,pbody)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101-element Vector{Float64}:
 10.296809749528707
 11.557811908525963
 12.868050991439402
 14.22720252265412
 15.634723162565262
 17.089837174178953
 18.591523737538612
 20.138505340589656
 21.729237481428008
 23.361899918828186
  ⋮
 25.52347752242912
 24.28969830984706
 23.08772797914915
 21.91806205064613
 20.78107553248585
 19.677029824367516
 18.606079648882357
 17.568279969353398
 16.56359285643376</code></pre><p>The output vector is the magnetic anomaly at each of the observation points specified above.</p><p>Now we can plot the results (e.g., using <code>CairoMakie</code>):</p><pre><code class="language-julia hljs">using CairoMakie

fig = Figure()

ax1 = Axis(fig[1,1],title=&quot;Magnetic anomaly&quot;,xlabel=&quot;x&quot;,ylabel=&quot;mag. anom.&quot;)
scatter!(ax1,xzobs[:,1],tmag)

ax2 = Axis(fig[2,1],title=&quot;Polygonal bodies&quot;,xlabel=&quot;x&quot;,ylabel=&quot;z&quot;)
x1 = [pbody.geom.bo[1].ver1[:,1]...,pbody.geom.bo[1].ver2[end,1]]
y1 = [pbody.geom.bo[1].ver1[:,2]...,pbody.geom.bo[1].ver2[end,2]]
scatterlines!(ax2,x1,y1)
x2 = [pbody.geom.bo[2].ver1[:,1]...,pbody.geom.bo[2].ver2[end,1]]
y2 = [pbody.geom.bo[2].ver1[:,2]...,pbody.geom.bo[2].ver2[end,2]]
scatterlines!(ax2,x2,y2)
ax2.yreversed=true

linkxaxes!(ax1,ax2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CairoMakie.Screen{SVG}
</code></pre><p><img src="images/mag.svg" alt/></p><h2 id="Tutorial-for-gravity-calculations"><a class="docs-heading-anchor" href="#Tutorial-for-gravity-calculations">Tutorial for gravity calculations</a><a id="Tutorial-for-gravity-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-for-gravity-calculations" title="Permalink"></a></h2><p>First load the module,</p><pre><code class="language-julia hljs">using MagGravPoly.MG2D</code></pre><p>then define an array containing the location of the observation points, where the first column represents the <span>$x$</span> position and the second the  <span>$z$</span> position. Remark: <span>$z$</span> points <em>downward</em>! So the observations have a negative <span>$z$</span> in this case.</p><pre><code class="language-julia hljs"># number of observations
N=101
xzobs = [LinRange(0.0,120.0,N) -1.0*ones(N)]</code></pre><p>In order to describe the polygonal bodies, two objects need to be specifies: 1)  an array containing all the positions of the vertices (first column represents the <span>$x$</span> position and the second the  <span>$z$</span> position) and 2) a mapping relating each polygonal body to its vertices. The position of vertices <em>must</em> be specifyied in a <strong>counterclockwise</strong> order.</p><pre><code class="language-julia hljs"># vertices of the poligonal bodies
vertices  = [35.0 50.0;
             65.0 50.0;
             80.0 35.0;
             65.0 20.0;
             35.0 20.0;
             20.0 35.0;
             90.0 60.0;
             95.0 40.0]

# indices of vertices for the first polygon
ind1 = collect(1:6)
# indices of vertices for the second polygon
ind2 = [2,7,8,3]
# define the two bodies in term of indices
bodyindices = [ind1,ind2]</code></pre><p>Now, we specify the density for each of the polygonal bodies</p><pre><code class="language-julia hljs"># two bodies in this case
rho = [2000.0,3000.0]</code></pre><p>Finally, construct the  poligonal body object by instantiating a <code>GravPolygBodies2D</code> structure. Here we can determine the type of forward calculation, i.e., 2D, 2.5D or 2.75D by specifying the variable <code>ylatext</code>. There are three cases:</p><ol><li>if <code>ylatext=nothing</code> then the polygonal bodies are considered to be extending laterally to infinity, hence a pure 2D forward calculation</li><li>if <code>ylatext</code> is a single real number, then the forward computation is 2.5D, i.e., the polygonal bodies extend laterally on both sides by an amount specified by the value of <code>ylatext</code></li><li>if <code>ylatext</code> is a two-element vector, then the forward computation is 2.75D, i.e., the polygonal bodies extend laterally from <code>ylatext[1]</code> to <code>ylatex[2]</code> (with the condition <code>ylatex[2]&gt;ylatex[1]</code>). </li></ol><p>Here we choose to run a 2.75D forward computation:</p><pre><code class="language-julia hljs">pbody = GravPolygBodies2D(bodyindices,vertices,rho,ylatext=[50.0,90.0])</code></pre><p>At this point the gravity field can be computed:</p><pre><code class="language-julia hljs">tgrav = tgravpolybodies2D(xzobs,pbody)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101-element Vector{Float64}:
 0.043099866346709335
 0.043998790656084405
 0.044907859709626456
 0.04582641973712609
 0.04675375980023228
 0.04768911098561322
 0.04863164588041108
 0.0495804783552574
 0.05053466367864151
 0.05149319898413085
 ⋮
 0.05120452930761636
 0.05028175203555816
 0.04936331720132698
 0.048450080798166435
 0.047542850268447345
 0.04664238439962175
 0.045749393448459116
 0.04486453947977988
 0.043988436904790734</code></pre><p>The output vector is the gravity anomaly at each of the observation points specified above.</p><p>Now we can plot the results (e.g., using <code>CairoMakie</code>):</p><pre><code class="language-julia hljs">using CairoMakie

fig = Figure()

ax1 = Axis(fig[1,1],title=&quot;Gravity anomaly&quot;,xlabel=&quot;x&quot;,ylabel=&quot;grav. anom.&quot;)
scatter!(ax1,xzobs[:,1],tgrav)

ax2 = Axis(fig[2,1],title=&quot;Polygonal bodies&quot;,xlabel=&quot;x&quot;,ylabel=&quot;z&quot;)
x1 = [pbody.geom.bo[1].ver1[:,1]...,pbody.geom.bo[1].ver2[end,1]]
y1 = [pbody.geom.bo[1].ver1[:,2]...,pbody.geom.bo[1].ver2[end,2]]
scatterlines!(ax2,x1,y1)
x2 = [pbody.geom.bo[2].ver1[:,1]...,pbody.geom.bo[2].ver2[end,1]]
y2 = [pbody.geom.bo[2].ver1[:,2]...,pbody.geom.bo[2].ver2[end,2]]
scatterlines!(ax2,x2,y2)
ax2.yreversed=true

linkxaxes!(ax1,ax2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CairoMakie.Screen{SVG}
</code></pre><p><img src="images/grav.svg" alt/></p><h2 id="Tutorial-for-joint-mag-and-grav"><a class="docs-heading-anchor" href="#Tutorial-for-joint-mag-and-grav">Tutorial for joint mag and grav</a><a id="Tutorial-for-joint-mag-and-grav-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-for-joint-mag-and-grav" title="Permalink"></a></h2><p>First load the modules,</p><pre><code class="language-julia hljs">using MagGravPoly.MG2D</code></pre><p>then define 1) the angle between the Magnetic Field&#39;s North and the model profile, 2) an array containing the location of the observation points along it, where the first column represents the <span>$x$</span> position and the second the  <span>$z$</span> position. Remark: <span>$z$</span> points <em>downward</em>! So the observations have a negative <span>$z$</span> in this case.</p><pre><code class="language-julia hljs"># angle with the North axis
northxax = 90.0

# number of observations
N=101
xzobs_mag = [LinRange(0.0,120.0,N) -1.0*ones(N)]
xzobs_grav = copy(xzobs_mag)</code></pre><p>In order to describe the polygonal bodies, two objects need to be specifies: 1)  an array containing all the positions of the vertices (first column represents the <span>$x$</span> position and the second the  <span>$z$</span> position) and 2) a mapping relating each polygonal body to its vertices. The position of vertices <em>must</em> be specifyied in a <strong>counterclockwise</strong> order.</p><pre><code class="language-julia hljs"># vertices of the poligonal bodies
vertices  = [35.0 50.0;
             65.0 50.0;
             80.0 35.0;
             65.0 20.0;
             35.0 20.0;
             20.0 35.0;
             90.0 60.0;
             95.0 40.0]

# indices of vertices for the first polygon
ind1 = collect(1:6)
# indices of vertices for the second polygon
ind2 = [2,7,8,3]
# define the two bodies in term of indices
bodyindices = [ind1,ind2]</code></pre><p>Now, we specify the density and magnetization for each of the polygonal bodies</p><pre><code class="language-julia hljs"># two bodies in this case
# densities
rho = [2000.0,3000.0]
# induced magnetizations
Jind = MagnetizVector(mod=[4.9,1.0],Ideg=[0.0,0.0],Ddeg=[5.0,5.0])
# remanent magnetizations
Jrem = MagnetizVector(mod=[3.1,1.5],Ideg=[45.0,-45.0],Ddeg=[0.0,0.0])</code></pre><p>Finally, construct the poligonal body object by instantiating a <code>JointPolygBodies2D</code> structure. Here we can determine the type of forward calculation, i.e., 2D, 2.5D or 2.75D by specifying the variable <code>ylatext</code>. There are three cases:</p><ol><li>if <code>ylatext=nothing</code> then the polygonal bodies are considered to be extending laterally to infinity, hence a pure 2D forward calculation</li><li>if <code>ylatext</code> is a single real number, then the forward computation is 2.5D, i.e., the polygonal bodies extend laterally on both sides by an amount specified by the value of <code>ylatext</code></li><li>if <code>ylatext</code> is a two-element vector, then the forward computation is 2.75D, i.e., the polygonal bodies extend laterally from <code>ylatext[1]</code> to <code>ylatex[2]</code> (with the condition <code>ylatex[2]&gt;ylatex[1]</code>). </li></ol><p>Here we choose to run a 2.75D forward computation:</p><pre><code class="language-julia hljs">pbody = JointPolygBodies2D(bodyindices,vertices,Jind,Jrem,rho,ylatext=[50.0,90.0])</code></pre><p>At this point the gravity and magnetic fields can be computed:</p><pre><code class="language-julia hljs"># compute the gravity anomaly and total field magnetic anomaly
tgrav,tmag = tjointpolybodies2D(xzobs_grav,xzobs_mag,northxax,pbody)</code></pre><p>The output vectors are the gravity and magnetic anomalies at each of the observation points specified above.</p><p>Alternatively, in the 2D case we could choose among other forward formulations implemented, specified as strings. Now we choose as forward types for the gravity and magnetic case <code>&quot;wonbev&quot;</code> and <code>&quot;talwani_red&quot;</code> respectively (see docs of <code>MagGravPoly</code> for details):</p><pre><code class="language-julia hljs">pbody = JointPolygBodies2D(bodyindices,vertices,Jind,Jrem,rho,ylatext=nothing)
# type of forward algorithms of the gravity and magnetic case
forwtype_grav = &quot;wonbev&quot;
forwtype_mag = &quot;talwani_red&quot;
# compute the gravity anomaly and total field magnetic anomaly
tgrav,tmag = tjointpolybodies2Dgen(xzobs_grav,xzobs_mag,northxax,pbody,forwtype_grav,forwtype_mag)</code></pre><p>Now we can plot the results (e.g., using <code>CairoMakie</code>):</p><pre><code class="language-julia hljs">using CairoMakie

fig = Figure()

ax1 = Axis(fig[1,1],title=&quot;Gravity anomaly&quot;,xlabel=&quot;x&quot;,ylabel=&quot;grav. anom.&quot;)
scatter!(ax1,xzobs_grav[:,1],tgrav)

ax2 = Axis(fig[2,1],title=&quot;Total-field magnetic anomaly&quot;,xlabel=&quot;x&quot;,ylabel=&quot;mag. anom.&quot;)
scatter!(ax2,xzobs_mag[:,1],tmag)

ax3 = Axis(fig[3,1],title=&quot;Polygonal bodies&quot;,xlabel=&quot;x&quot;,ylabel=&quot;z&quot;)
x1 = [pbody.geom.bo[1].ver1[:,1]...,pbody.geom.bo[1].ver2[end,1]]
y1 = [pbody.geom.bo[1].ver1[:,2]...,pbody.geom.bo[1].ver2[end,2]]
scatterlines!(ax3,x1,y1)
x2 = [pbody.geom.bo[2].ver1[:,1]...,pbody.geom.bo[2].ver2[end,1]]
y2 = [pbody.geom.bo[2].ver1[:,2]...,pbody.geom.bo[2].ver2[end,2]]
scatterlines!(ax3,x2,y2)
ax3.yreversed=true

linkxaxes!(ax1,ax2,ax3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CairoMakie.Screen{SVG}
</code></pre><p><img src="images/jointgravmag.svg" alt/></p><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><h3 id="Module"><a class="docs-heading-anchor" href="#Module">Module</a><a id="Module-1"></a><a class="docs-heading-anchor-permalink" href="#Module" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly" href="#MagGravPoly"><code>MagGravPoly</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>MagGravPoly</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MagGravPoly.jl#L3-L6">source</a></section></article><h3 id="Data-structures"><a class="docs-heading-anchor" href="#Data-structures">Data structures</a><a id="Data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-structures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.MagPolygBodies2D" href="#MagGravPoly.MG2D.MagPolygBodies2D"><code>MagGravPoly.MG2D.MagPolygBodies2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MagPolygBodies2D</code></pre><p>Structure containing a set of polygonal bodies (described by their segments and all vertices) along with their magnetizations (Induced + Remanent). To create an instance, input an array of vectors of indices    (of vertices) for each body and the array of all the vertices.</p><p><strong>Fields</strong></p><ul><li><p><code>geom::MagGravPoly.GeoPoly.PolygBodies2D</code>: structure defining the geometry of the bodies</p></li><li><p><code>Jind::MagGravPoly.MG2D.MagnetizVector</code>: vector of induced magnetizations</p></li><li><p><code>Jrem::MagGravPoly.MG2D.MagnetizVector</code>: vector of remnant magnetizations</p></li><li><p><code>ylatext::Union{Nothing, Vector{&lt;:Real}}</code>: [y1 y2] = lateral extension of the polygonal body. Tipycally y1 is negative since observations are at y=0.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/mag/mag_datastruct.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.GravPolygBodies2D" href="#MagGravPoly.MG2D.GravPolygBodies2D"><code>MagGravPoly.MG2D.GravPolygBodies2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GravPolygBodies2D</code></pre><p>Structure containing a set of polygonal bodies (described by their segments and all vertices) along with their densities. To create an instance, input an array of vectors of indices (of vertices) for each body and the array of all the vertices.</p><p><strong>Fields</strong></p><ul><li><p><code>geom::MagGravPoly.GeoPoly.PolygBodies2D</code>: structure defining the geometry of the bodies</p></li><li><p><code>rho::Vector{&lt;:Real}</code>: vector of densities</p></li><li><p><code>ylatext::Union{Nothing, Vector{&lt;:Real}}</code>: [y1 y2] = lateral extension of the polygonal body. Tipycally y1 is negative since observations are at y=0.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/grav/grav_datastruct.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.JointPolygBodies2D" href="#MagGravPoly.MG2D.JointPolygBodies2D"><code>MagGravPoly.MG2D.JointPolygBodies2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct JointPolygBodies2D</code></pre><p>Structure containing a set of polygonal bodies (described by their segments and all vertices) along with their magnetizations (Induced + Remanent) and densities. To create an instance, input an array of vectors of indices    (of vertices) for each body and the array of all the vertices.</p><p><strong>Fields</strong></p><ul><li><p><code>geom::MagGravPoly.GeoPoly.PolygBodies2D</code>: structure defining the geometry of the bodies</p></li><li><p><code>Jind::MagGravPoly.MG2D.MagnetizVector</code>: vector of induced magnetizations</p></li><li><p><code>Jrem::MagGravPoly.MG2D.MagnetizVector</code>: vector of remnant magnetizations</p></li><li><p><code>rho::Vector{&lt;:Real}</code>: vector of densities</p></li><li><p><code>ylatext::Union{Nothing, Vector{&lt;:Real}}</code>: [y1 y2] = lateral extension of the polygonal body. Tipycally y1 is negative since observations are at y=0.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/joint/joint_datastruct.jl#L3">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Vertices of the polygonal bodies must be provided  in <strong>counterclockwise order</strong> to the function <code>JointPolygBodies2D</code> in order to perform gravity and magnetic anomaly calculations.</p></div></div><h3 id="Forward-functions"><a class="docs-heading-anchor" href="#Forward-functions">Forward functions</a><a id="Forward-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-functions" title="Permalink"></a></h3><h4 id="Magnetics"><a class="docs-heading-anchor" href="#Magnetics">Magnetics</a><a id="Magnetics-1"></a><a class="docs-heading-anchor-permalink" href="#Magnetics" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.tmagpolybodies2D" href="#MagGravPoly.MG2D.tmagpolybodies2D"><code>MagGravPoly.MG2D.tmagpolybodies2D</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tmagpolybodies2D(
    xzobs::Matrix{&lt;:Real},
    northxax::Real,
    pbodies::MagGravPoly.MG2D.MagPolygBodies2D
) -&gt; Vector{&lt;:Real}
</code></pre><p>Total magnetic field (2D or 2.75D) for a set of polygonal bodies defined by their corners. Takes into account both induced and remnant magnetization. 2D formulation based on Talwani &amp; Heitzler (1964), the default algorithm in Mag2Dpoly package. 2.75D formulation based on Rasmussen &amp; Pedersen (1979) and Campbell (1983).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/mag/mag_2dpolybodies.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.tmagpolybodies2Dgen" href="#MagGravPoly.MG2D.tmagpolybodies2Dgen"><code>MagGravPoly.MG2D.tmagpolybodies2Dgen</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tmagpolybodies2Dgen(
    xzobs::Matrix{&lt;:Real},
    northxax::Real,
    pbodies::MagGravPoly.MG2D.MagPolygBodies2D,
    forwardtype::String
) -&gt; Vector{&lt;:Real}
</code></pre><p>Total magnetic field (2D) for a set of polygonal bodies defined by their corners. Takes into account both induced and remnant magnetization. Generic version containing four different algorithm formulations <code>forwardtype</code>, passed as a string:</p><ul><li>&quot;talwani&quot;      –&gt; Talwani &amp; Heitzler (1964)</li><li>&quot;talwani_red&quot;  –&gt; Talwani &amp; Heitzler (1964) rederived from Kravchinsky et al. (2019)</li><li>&quot;krav&quot;         –&gt; Kravchinsky et al. (2019) rectified by Ghirotto et al. (2021)</li><li>&quot;wonbev&quot;       –&gt; Won &amp; Bevis (1987)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/mag/mag_2dpolybodies.jl#L41">source</a></section></article><h4 id="Gravity"><a class="docs-heading-anchor" href="#Gravity">Gravity</a><a id="Gravity-1"></a><a class="docs-heading-anchor-permalink" href="#Gravity" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.tgravpolybodies2D" href="#MagGravPoly.MG2D.tgravpolybodies2D"><code>MagGravPoly.MG2D.tgravpolybodies2D</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tgravpolybodies2D(
    xzobs::Matrix{&lt;:Real},
    pbodies::MagGravPoly.MG2D.GravPolygBodies2D
) -&gt; Vector{&lt;:Real}
</code></pre><p>Vertical attraction (2D or 2.75D) for a set of polygonal bodies defined by their corners. 2D formulation based on Talwani et al. (1959) and Blakely (1995).  2.75D formulation based on Rasmussen &amp; Pedersen (1979). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/grav/grav_2dpolybodies.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.tgravpolybodies2Dgen" href="#MagGravPoly.MG2D.tgravpolybodies2Dgen"><code>MagGravPoly.MG2D.tgravpolybodies2Dgen</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tgravpolybodies2Dgen(
    xzobs::Matrix{&lt;:Real},
    pbodies::MagGravPoly.MG2D.GravPolygBodies2D,
    forwardtype::String
) -&gt; Vector{&lt;:Real}
</code></pre><p>Vertical attraction (2D) for a set of polygonal bodies defined by their corners. Generic version containing two different algorithm formulations <code>forwardtype</code>, passed as a string:</p><ul><li>&quot;talwani&quot;      –&gt; Talwani et al. (1959)</li><li>&quot;wonbev&quot;       –&gt; Won &amp; Bevis (1987)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/grav/grav_2dpolybodies.jl#L36">source</a></section></article><h4 id="Joint-mag-and-grav"><a class="docs-heading-anchor" href="#Joint-mag-and-grav">Joint mag and grav</a><a id="Joint-mag-and-grav-1"></a><a class="docs-heading-anchor-permalink" href="#Joint-mag-and-grav" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.tjointpolybodies2D" href="#MagGravPoly.MG2D.tjointpolybodies2D"><code>MagGravPoly.MG2D.tjointpolybodies2D</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tjointpolybodies2D(
    grav_xzobs::Matrix{&lt;:Real},
    mag_xzobs::Matrix{&lt;:Real},
    northxax::Real,
    pbodies::MagGravPoly.MG2D.JointPolygBodies2D
) -&gt; Tuple{Vector{&lt;:Real}, Vector{&lt;:Real}}
</code></pre><p>Function to return the vertical attraction &amp; total magnetic field (2D or 2.75D) for a set of polygonal bodies defined by their corners. Takes into account both induced and remnant magnetization. 2D formulations based on Talwani et al. (1959), Talwani &amp; Heitzler (1964) and Blakely (1995). 2.75D formulations based on Rasmussen &amp; Pedersen (1979) and Campbell (1983).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/joint/joint_2dpolybodies.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.tjointpolybodies2Dgen" href="#MagGravPoly.MG2D.tjointpolybodies2Dgen"><code>MagGravPoly.MG2D.tjointpolybodies2Dgen</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tjointpolybodies2Dgen(
    grav_xzobs::Matrix{&lt;:Real},
    mag_xzobs::Matrix{&lt;:Real},
    northxax::Real,
    pbodies::MagGravPoly.MG2D.JointPolygBodies2D,
    forwtype_grav::String,
    forwtype_mag::String
) -&gt; Tuple{Vector{&lt;:Real}, Vector{&lt;:Real}}
</code></pre><p>Vertical attraction &amp; Total magnetic field (2D or 2.75D) for a set of polygonal bodies defined by their corners. Takes into account both induced and remnant magnetization. Gravity calculation is based on two different algorithm formulations defined by <code>forwtype_grav</code>, passed as a string:</p><ul><li>&quot;talwani&quot;      –&gt; Talwani et al. (1959)</li><li>&quot;wonbev&quot;       –&gt; Won &amp; Bevis (1987)</li></ul><p>Magnetic calculation instead is based on four different algorithm formulations defined by <code>forwtype_mag</code>, passed as a string:</p><ul><li>&quot;talwani&quot;      –&gt; Talwani &amp; Heitzler (1964)</li><li>&quot;talwani_red&quot;  –&gt; Talwani &amp; Heitzler (1964) rederived from Kravchinsky et al. (2019)</li><li>&quot;krav&quot;         –&gt; Kravchinsky et al. (2019) rectified by Ghirotto et al. (2021)</li><li>&quot;wonbev&quot;       –&gt; Won &amp; Bevis (1987)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/joint/joint_2dpolybodies.jl#L44">source</a></section></article><h3 id="HMC-helper-functions"><a class="docs-heading-anchor" href="#HMC-helper-functions">HMC helper functions</a><a id="HMC-helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#HMC-helper-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.HMCMag2Dpoly.Mag2DpolyProb" href="#MagGravPoly.MG2D.HMCMag2Dpoly.Mag2DpolyProb"><code>MagGravPoly.MG2D.HMCMag2Dpoly.Mag2DpolyProb</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Julia structure to define a magnetic problem for HMC. The users must indicate the method to compute misfit gradient by <code>ADkind</code> string, choosing among <code>FWDdiff</code>, <code>REVdiffTAPE</code> or <code>REVdiffTAPEcomp</code>.  For an explanation of the automatic differentiation method, the reader is invited to look at the documentation  relative to the Julia packages <code>ForwardDiff</code> and <code>ReverseDiff</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/mag/HMCmag2Dpoly.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.HMCGrav2Dpoly.Grav2DpolyProb" href="#MagGravPoly.MG2D.HMCGrav2Dpoly.Grav2DpolyProb"><code>MagGravPoly.MG2D.HMCGrav2Dpoly.Grav2DpolyProb</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Julia structure to define a gravity problem for HMC. The users must indicate the method to compute the misfit gradient by <code>ADkind</code> string, choosing among <code>FWDdiff</code>, <code>REVdiffTAPE</code> or <code>REVdiffTAPEcomp</code>.  For an explanation of the automatic differentiation method, the reader is invited to look at the documentation  relative to the Julia packages <code>ForwardDiff</code> and <code>ReverseDiff</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/grav/HMCgrav2Dpoly.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.HMCJointMG2D.Joint2DpolyProb" href="#MagGravPoly.MG2D.HMCJointMG2D.Joint2DpolyProb"><code>MagGravPoly.MG2D.HMCJointMG2D.Joint2DpolyProb</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Julia structure to define a joint magnetic and gravity problem for HMC.  The users must indicate the method to compute misfit gradient for both the magnetic and gravity problem by <code>ADkindmag</code> and <code>ADkindgrav</code> strings, respectively, choosing among <code>FWDdiff</code>, <code>REVdiffTAPE</code> or <code>REVdiffTAPEcomp</code>.  For an explanation of the automatic differentiation method, the reader is invited to look at the documentation  relative to the Julia packages <code>ForwardDiff</code> and <code>ReverseDiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/joint/HMCJointMG2D.jl#L26">source</a></section></article><h3 id="Misfit-structure-and-functions"><a class="docs-heading-anchor" href="#Misfit-structure-and-functions">Misfit structure &amp; functions</a><a id="Misfit-structure-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Misfit-structure-and-functions" title="Permalink"></a></h3><h4 id="Magnetics-2"><a class="docs-heading-anchor" href="#Magnetics-2">Magnetics</a><a class="docs-heading-anchor-permalink" href="#Magnetics-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.Mag2DPolyMisf" href="#MagGravPoly.MG2D.Mag2DPolyMisf"><code>MagGravPoly.MG2D.Mag2DPolyMisf</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Julia structure containing all data required for both misfit and gradient calculations. The <code>whichpar</code> Symbol indicates which paramters the user would like to invert for. It should be <code>:all</code>, <code>:vertices</code> or <code>:magnetization</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/mag/mag_derivatives.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.precalcADstuffmag" href="#MagGravPoly.MG2D.precalcADstuffmag"><code>MagGravPoly.MG2D.precalcADstuffmag</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precalcADstuffmag(
    magmisf::MagGravPoly.MG2D.Mag2DPolyMisf,
    ADkind::String,
    vecmodpar::AbstractArray
) -&gt; Union{Nothing, ForwardDiff.GradientConfig{T} where T&lt;:(ForwardDiff.Tag{F} where F&lt;:MagGravPoly.MG2D.Mag2DPolyMisf), ReverseDiff.CompiledTape{T} where T&lt;:(ReverseDiff.GradientTape{F, I} where {F&lt;:MagGravPoly.MG2D.Mag2DPolyMisf, I&lt;:ReverseDiff.TrackedArray}), ReverseDiff.GradientTape{F, I} where {F&lt;:MagGravPoly.MG2D.Mag2DPolyMisf, I&lt;:ReverseDiff.TrackedArray}}
</code></pre><p>Pre-calculate some parameters before computing the gradient of the misfit using automatic differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/mag/mag_derivatives.jl#L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.calcmisfmag" href="#MagGravPoly.MG2D.calcmisfmag"><code>MagGravPoly.MG2D.calcmisfmag</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calcmisfmag(
    modpar::AbstractArray,
    magmisf::MagGravPoly.MG2D.Mag2DPolyMisf
) -&gt; Any
</code></pre><p>Function to compute the value of the misfit functional with respect to the model parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/mag/mag_derivatives.jl#L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.calc∇misfmag" href="#MagGravPoly.MG2D.calc∇misfmag"><code>MagGravPoly.MG2D.calc∇misfmag</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc∇misfmag(
    magmisf::MagGravPoly.MG2D.Mag2DPolyMisf,
    modpar::AbstractArray,
    ADkind::String,
    autodiffstuff
) -&gt; Any
</code></pre><p>Function to compute the gradient of misfit with respect to the model parameters required for HMC inversions.  The gradient is computed by means of automatic differentiation using one of three different methods. The user must indicate the method by <code>ADkind</code> string, choosing among <code>FWDdiff</code>, <code>REVdiffTAPE</code> or <code>REVdiffTAPEcomp</code>.  For an explanation about the automatic differentiation method, the reader is invited to look at the documentation  relative to the Julia packages <code>ForwardDiff</code> and <code>ReverseDiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/mag/mag_derivatives.jl#L250">source</a></section></article><h4 id="Gravity-2"><a class="docs-heading-anchor" href="#Gravity-2">Gravity</a><a class="docs-heading-anchor-permalink" href="#Gravity-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.Grav2DPolyMisf" href="#MagGravPoly.MG2D.Grav2DPolyMisf"><code>MagGravPoly.MG2D.Grav2DPolyMisf</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><ul><li><p><code>bodyindices::Array{Vector{I}, 1} where I&lt;:Integer</code></p></li><li><p><code>xzobs::Matrix{F} where F&lt;:Real</code></p></li><li><p><code>tgravobs::Vector{F} where F&lt;:Real</code></p></li><li><p><code>invcovmat::AbstractMatrix{F} where F&lt;:Real</code></p></li><li><p><code>whichpar::Symbol</code></p></li><li><p><code>allvert::Union{Nothing, Matrix{F}} where F&lt;:Real</code></p></li><li><p><code>rho::Union{Nothing, Vector{F}} where F&lt;:Real</code></p></li><li><p><code>ylatext::Union{Nothing, Vector{F}} where F&lt;:Real</code></p></li></ul><p>Julia structure containing all data required for both misfit and gradient calculations. The <code>whichpar</code> symbol indicates which paramters the user would like to invert for. It should be <code>:all</code>, <code>:vertices</code> or <code>:density</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/grav/grav_derivatives.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.precalcADstuffgrav" href="#MagGravPoly.MG2D.precalcADstuffgrav"><code>MagGravPoly.MG2D.precalcADstuffgrav</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precalcADstuffgrav(
    gravmisf::MagGravPoly.MG2D.Grav2DPolyMisf,
    ADkind::String,
    vecmodpar::AbstractArray
) -&gt; Union{Nothing, ForwardDiff.GradientConfig{T} where T&lt;:(ForwardDiff.Tag{F} where F&lt;:MagGravPoly.MG2D.Grav2DPolyMisf), ReverseDiff.CompiledTape{T} where T&lt;:(ReverseDiff.GradientTape{F, I} where {F&lt;:MagGravPoly.MG2D.Grav2DPolyMisf, I&lt;:ReverseDiff.TrackedArray}), ReverseDiff.GradientTape{F, I} where {F&lt;:MagGravPoly.MG2D.Grav2DPolyMisf, I&lt;:ReverseDiff.TrackedArray}}
</code></pre><p>Pre-calculate some parameters before computing the gradient of the misfit using automatic differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/grav/grav_derivatives.jl#L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.calcmisfgrav" href="#MagGravPoly.MG2D.calcmisfgrav"><code>MagGravPoly.MG2D.calcmisfgrav</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calcmisfgrav(
    modpar::AbstractArray,
    gravmisf::MagGravPoly.MG2D.Grav2DPolyMisf
) -&gt; Any
</code></pre><p>Function to compute the value of the misfit functional with respect to the model parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/grav/grav_derivatives.jl#L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.calc∇misfgrav" href="#MagGravPoly.MG2D.calc∇misfgrav"><code>MagGravPoly.MG2D.calc∇misfgrav</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc∇misfgrav(
    gravmisf::MagGravPoly.MG2D.Grav2DPolyMisf,
    modpar::AbstractArray,
    ADkind::String,
    autodiffstuff
) -&gt; Any
</code></pre><p>Function to compute the gradient of the misfit with respect to the model parameters as required for HMC inversions.  The gradient is computed by means of automatic differentiation using one of three different methods. The user must indicate the method by <code>ADkind</code> string, choosing among <code>FWDdiff</code>, <code>REVdiffTAPE</code> or <code>REVdiffTAPEcomp</code>.  For an explanation about the automatic differentiation method, the reader is invited to look at the documentation  relative to the Julia packages <code>ForwardDiff</code> and <code>ReverseDiff</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/grav/grav_derivatives.jl#L215">source</a></section></article><h3 id="Useful-functions-for-magnetics"><a class="docs-heading-anchor" href="#Useful-functions-for-magnetics">Useful functions for magnetics</a><a id="Useful-functions-for-magnetics-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-functions-for-magnetics" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>These functions are not exported. To call them type <code>MagGravPoly.MG2D</code> before the name of the functions.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.convert_H_to_B_nT" href="#MagGravPoly.MG2D.convert_H_to_B_nT"><code>MagGravPoly.MG2D.convert_H_to_B_nT</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_H_to_B_nT(H_Am::Real) -&gt; Any
</code></pre><p>Convert from the field H (A/m) to B (nT).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/mag/mag_utils.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.convert_B_nT_to_H" href="#MagGravPoly.MG2D.convert_B_nT_to_H"><code>MagGravPoly.MG2D.convert_B_nT_to_H</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_B_nT_to_H(B_nT::Real) -&gt; Any
</code></pre><p>Convert from the field B (nT) to H (A/m).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/mag/mag_utils.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagGravPoly.MG2D.magcomp" href="#MagGravPoly.MG2D.magcomp"><code>MagGravPoly.MG2D.magcomp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">magcomp(
    modJind::Real,
    Iind::Real,
    Dind::Real,
    modJrem::Real,
    Irem::Real,
    Drem::Real,
    C::Real
) -&gt; Tuple{Any, Any, Any}
</code></pre><p>Vector addition of magnetic (remnant + induced) components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GinvLab/MagGravPoly.jl/blob/ba4dc99821be29f22b2436d62d52b58773d8a710/src/MG2D/mag/mag_utils.jl#L4">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="geopoly/">GeoPoly »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 3 February 2025 13:07">Monday 3 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
