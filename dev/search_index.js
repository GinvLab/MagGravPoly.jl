var documenterSearchIndex = {"docs":
[{"location":"geopoly/#GeoPoly","page":"GeoPoly","title":"GeoPoly","text":"","category":"section"},{"location":"geopoly/#User-guide","page":"GeoPoly","title":"User guide","text":"","category":"section"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"GeoPoly is a Julia utility contained in the package MagGravPoly and developed for handling polygonal shapes in the framework of 2D to 2.75D potential-fields forward and inverse modeling. ","category":"page"},{"location":"geopoly/#Tutorial","page":"GeoPoly","title":"Tutorial","text":"","category":"section"},{"location":"geopoly/#Check-the-orientation-of-a-polygon","page":"GeoPoly","title":"Check the orientation of a polygon","text":"","category":"section"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"First load the module and define a list of vertices of the poligonal bodies  and the relative indices mapping each body to its vertices:","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"using MagGravPoly.GeoPoly\n# vertices of the poligonal bodies\nvertices  = [35.0 50.0;\n             65.0 50.0;\n             80.0 35.0;\n             65.0 20.0;\n             35.0 20.0;\n             20.0 35.0]\n\t\t\t \n# indices of vertices for the body\nind1 = collect(1:6)\nbodyindices = [ind1]\n# construct the poligonal body object\npbody = PolygBodies2D(bodyindices,vertices)\nnothing # hide","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"and then checks if the polygon is defined in a clockwise or counter-clockwise order: ","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"# check about the order\nfor i=1:pbody.nbo\naclk = checkanticlockwiseorder(pbody.bo[i])\n@show aclk\nend","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"In fact plotting the polygon:","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"using PyPlot\nfigure()\nfor i=1:length(bodyindices)\nx = copy(pbody.bo[i].ver1[:,1])\ny = copy(pbody.bo[i].ver1[:,2])\nappend!(x,pbody.bo[i].ver1[1,1])\nappend!(y,pbody.bo[i].ver1[1,2])\np=PyPlot.plot(x,y,\"-o\")\nfor i=1:length(x)-1\ns=string(i)\nif i<=1\ntxtalign = \"left\"\nelse\ntxtalign = \"right\"\nend\ntext(x[i],y[i],s=s,horizontalalignment=txtalign,\nfontsize=16,verticalalignment=\"top\")\nend\nend\ngca().invert_yaxis()","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"is easy to see that is counter-clockwise oriented. (Image: )","category":"page"},{"location":"geopoly/#Check-and-fixing-for-crossing-polygon-sides","page":"GeoPoly","title":"Check and fixing for crossing polygon sides","text":"","category":"section"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"First load the module and define a list of vertices of the poligonal bodies  and the relative indices mapping each body to its vertices:","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"using MagGravPoly.GeoPoly\n# vertices of the poligonal bodies\nvertices  = [35.0 50.0;\n             80.0 35.0;\n             65.0 50.0;\n             65.0 20.0;\n             35.0 20.0;\n             20.0 35.0]\n\t\t\t \n# indices of vertices for the body\nind1 = collect(1:6)\nbodyindices = [ind1]\n# construct the poligonal body object\npbody = PolygBodies2D(bodyindices,vertices)\nnothing # hide","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"Now checks for any crossing polygon side:","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"chk = checkpoly(pbody.bo)\n@show chk[1]","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"In fact plotting the polygon:","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"using PyPlot\nfigure()\nfor i=1:length(bodyindices)\nx = copy(pbody.bo[i].ver1[:,1])\ny = copy(pbody.bo[i].ver1[:,2])\nappend!(x,pbody.bo[i].ver1[1,1])\nappend!(y,pbody.bo[i].ver1[1,2])\np=PyPlot.plot(x,y,\"-o\")\nfor i=1:length(x)-1\ns=string(i)\nif i<=1\ntxtalign = \"left\"\nelse\ntxtalign = \"right\"\nend\ntext(x[i],y[i],s=s,horizontalalignment=txtalign,\nfontsize=16,verticalalignment=\"top\")\nend\nend\ngca().invert_yaxis()","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"(Image: )","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"We can try to fix the polygonal geometries using the verpolyshift! function:","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"# polygon fixing\nGeoPoly.verpolyshift!(pbody.bo)","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"and the results will be the following:","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"(Image: )","category":"page"},{"location":"geopoly/#Public-API","page":"GeoPoly","title":"Public API","text":"","category":"section"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"MagGravPoly.GeoPoly","category":"page"},{"location":"geopoly/#MagGravPoly.GeoPoly","page":"GeoPoly","title":"MagGravPoly.GeoPoly","text":"GeoPoly\n\nA module developed for handling polygonal shapes in the framework of 2D potential field forward and inverse modeling.\n\nExports\n\nBodySegments2D\nPolygBodies2D\nTopoEdges\ncalcareamanypoly\ncalcareapoly\ncheckanticlockwiseorder\ncheckbodyindices\ncheckpoly\nchecktopo\nselfintersectpoly\n\n\n\n\n\n","category":"module"},{"location":"geopoly/#Data-structures","page":"GeoPoly","title":"Data structures","text":"","category":"section"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"MagGravPoly.GeoPoly.BodySegments2D\nMagGravPoly.GeoPoly.PolygBodies2D","category":"page"},{"location":"geopoly/#MagGravPoly.GeoPoly.BodySegments2D","page":"GeoPoly","title":"MagGravPoly.GeoPoly.BodySegments2D","text":"struct BodySegments2D\n\nStructure containing the segments of a polygonal body. To create an instance a set of indices have to be passed on.\n\nFields\n\nver1::SubArray: (x,y) for first set of vertices (beginning of segments)\nver2::SubArray: (x,y) for second set of vertices (end of segments)\nnsegm::Integer: total number of segments\n\n\n\n\n\n","category":"type"},{"location":"geopoly/#MagGravPoly.GeoPoly.PolygBodies2D","page":"GeoPoly","title":"MagGravPoly.GeoPoly.PolygBodies2D","text":"struct PolygBodies2D\n\nStructure containing a set of polygonal bodies (described by their segments and all vertices). To create an instance, input an array of vectors of indices (of vertices) for each body and the array of all the vertices.\n\nFields\n\nbo::Vector{MagGravPoly.GeoPoly.BodySegments2D}: array of bodies defined by their vertices\nnbo::Integer: number of polygonal bodies\nallvert::AbstractMatrix{<:Real}: array of all vertices for all bodies\nbodyindices::Vector{<:Vector{<:Integer}}: array indices relating to the vertices in allvert\n\n\n\n\n\n","category":"type"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"warning: Warning\nVertices of the polygonal bodies must be provided  counterclockwise to the structure BodySegments2D to perform gravity & magnetic anomaly calculations using the functions in the packages MagGravPoly. To assess this use the function checkanticlockwiseorder.","category":"page"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"MagGravPoly.GeoPoly.TopoEdges","category":"page"},{"location":"geopoly/#MagGravPoly.GeoPoly.TopoEdges","page":"GeoPoly","title":"MagGravPoly.GeoPoly.TopoEdges","text":"Julia structure defining a topography as set of segments characterized by x and z coordinates and both angular coefficient and intercept.  \n\nFields\n\nverx::Vector{Vector{Float64}}: all x couples of topography coordinates\nverz::Vector{Vector{Float64}}: all z couples of topography coordinates\nmq::Vector{Vector{Float64}}: angular coefficients and segment intersepts of each coordinates couple\nxz::Matrix{Float64}: 2D array of (x,z) coordinates for topography\n\n\n\n\n\n","category":"type"},{"location":"geopoly/#Checking-geometries-functions","page":"GeoPoly","title":"Checking-geometries functions","text":"","category":"section"},{"location":"geopoly/#Single-polygonal-body","page":"GeoPoly","title":"Single polygonal body","text":"","category":"section"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"MagGravPoly.GeoPoly.intersectpairpoly\nMagGravPoly.GeoPoly.selfintersectpoly\nMagGravPoly.GeoPoly.checkall\nMagGravPoly.GeoPoly.checkanticlockwiseorder","category":"page"},{"location":"geopoly/#MagGravPoly.GeoPoly.intersectpairpoly","page":"GeoPoly","title":"MagGravPoly.GeoPoly.intersectpairpoly","text":"intersectpairpoly(\n    bo::Vector{MagGravPoly.GeoPoly.BodySegments2D}\n) -> Bool\n\n\nFunction to check if there are intersections beetween sides of a polygon in respect to neighbour polygons, returning a Boolean value (i.e. true or false).\n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.selfintersectpoly","page":"GeoPoly","title":"MagGravPoly.GeoPoly.selfintersectpoly","text":"selfintersectpoly(\n    bo::MagGravPoly.GeoPoly.BodySegments2D\n) -> Bool\n\n\nCheck if there is any self-intersection for a single polygon, returning a Boolean value (i.e. true or false).\n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.checkall","page":"GeoPoly","title":"MagGravPoly.GeoPoly.checkall","text":"checkall(\n    bos::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    topo::MagGravPoly.GeoPoly.TopoEdges\n) -> Vector{Symbol}\n\n\nCheck if there is any self-intersection considering all polygons beyond to topography crossing, returning three string values.\n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.checkanticlockwiseorder","page":"GeoPoly","title":"MagGravPoly.GeoPoly.checkanticlockwiseorder","text":"checkanticlockwiseorder(\n    body::MagGravPoly.GeoPoly.BodySegments2D\n) -> Bool\n\n\nCheck whether the polygonal body has segments ordered anticlockwise.\n\n\n\n\n\n","category":"function"},{"location":"geopoly/#Multiple-polygonal-bodies","page":"GeoPoly","title":"Multiple polygonal bodies","text":"","category":"section"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"MagGravPoly.GeoPoly.checktopo\nMagGravPoly.GeoPoly.checkpoly","category":"page"},{"location":"geopoly/#MagGravPoly.GeoPoly.checktopo","page":"GeoPoly","title":"MagGravPoly.GeoPoly.checktopo","text":"checktopo(\n    topo::MagGravPoly.GeoPoly.TopoEdges,\n    bo::Vector{MagGravPoly.GeoPoly.BodySegments2D}\n) -> Bool\n\n\nFunction to check if there is some polygon crossing the topography, returning a Boolean value (i.e. true or false).  \n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.checkpoly","page":"GeoPoly","title":"MagGravPoly.GeoPoly.checkpoly","text":"checkpoly(\n    bos::Vector{MagGravPoly.GeoPoly.BodySegments2D}\n) -> Tuple{Symbol, Symbol}\n\n\nCheck if there is any self-intersection considering all polygons, returning two string values.\n\n\n\n\n\n","category":"function"},{"location":"geopoly/#Fixing-geometries-functions","page":"GeoPoly","title":"Fixing-geometries functions","text":"","category":"section"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"MagGravPoly.GeoPoly.verpolyshift!\nMagGravPoly.GeoPoly.verpolyallshift!\nMagGravPoly.GeoPoly.vertoposhift!\nMagGravPoly.GeoPoly.fixall!","category":"page"},{"location":"geopoly/#MagGravPoly.GeoPoly.verpolyshift!","page":"GeoPoly","title":"MagGravPoly.GeoPoly.verpolyshift!","text":"verpolyshift!(\n    borg::Vector{MagGravPoly.GeoPoly.BodySegments2D}\n)\nverpolyshift!(\n    borg::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    blow::Union{Nothing, Vector{MagGravPoly.GeoPoly.BodySegments2D}}\n)\nverpolyshift!(\n    borg::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    blow::Union{Nothing, Vector{MagGravPoly.GeoPoly.BodySegments2D}},\n    bup::Union{Nothing, Vector{MagGravPoly.GeoPoly.BodySegments2D}}\n)\n\n\nFunction to check if there is intersection beetween sides of a polygon, trying to shift polygon vertices in order to avoid intersection. This algorithm shifts the polygon vertices in agreement with the mathematical properties of the Hamiltonian Dynamics.\n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.verpolyallshift!","page":"GeoPoly","title":"MagGravPoly.GeoPoly.verpolyallshift!","text":"verpolyallshift!(\n    borg::Vector{MagGravPoly.GeoPoly.BodySegments2D}\n)\nverpolyallshift!(\n    borg::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    blow::Union{Nothing, Vector{MagGravPoly.GeoPoly.BodySegments2D}}\n)\nverpolyallshift!(\n    borg::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    blow::Union{Nothing, Vector{MagGravPoly.GeoPoly.BodySegments2D}},\n    bup::Union{Nothing, Vector{MagGravPoly.GeoPoly.BodySegments2D}}\n)\n\n\nFunction to check if there are intersections beetween sides of a polygon in respect to neighbour polygons, trying to shift polygon vertices in order to avoid intersection. This algorithm shifts the polygon vertices in agreement with the mathematical properties of the Hamiltonian Dynamics.\n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.vertoposhift!","page":"GeoPoly","title":"MagGravPoly.GeoPoly.vertoposhift!","text":"vertoposhift!(\n    topo::MagGravPoly.GeoPoly.TopoEdges,\n    bo::Vector{MagGravPoly.GeoPoly.BodySegments2D}\n)\nvertoposhift!(\n    topo::MagGravPoly.GeoPoly.TopoEdges,\n    bo::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    blow::Union{Nothing, Vector{MagGravPoly.GeoPoly.BodySegments2D}}\n)\nvertoposhift!(\n    topo::MagGravPoly.GeoPoly.TopoEdges,\n    bo::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    blow::Union{Nothing, Vector{MagGravPoly.GeoPoly.BodySegments2D}},\n    bup::Union{Nothing, Vector{MagGravPoly.GeoPoly.BodySegments2D}}\n)\n\n\nFunction to check if there is some polygon crossing the topography, shifting the polygon vertices in order to avoid intersection. This algorithm shifts the polygon vertices in agreement with the mathematical properties of the Hamiltonian Dynamics.  \n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.fixall!","page":"GeoPoly","title":"MagGravPoly.GeoPoly.fixall!","text":"fixall!(\n    topo::MagGravPoly.GeoPoly.TopoEdges,\n    qbo::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    inters::Vector{Symbol}\n)\nfixall!(\n    topo::MagGravPoly.GeoPoly.TopoEdges,\n    qbo::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    inters::Vector{Symbol},\n    indices::Union{Nothing, Vector{Vector{<:Integer}}}\n)\nfixall!(\n    topo::MagGravPoly.GeoPoly.TopoEdges,\n    qbo::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    inters::Vector{Symbol},\n    indices::Union{Nothing, Vector{Vector{<:Integer}}},\n    lowcon::Union{Nothing, Vector{Float64}}\n)\nfixall!(\n    topo::MagGravPoly.GeoPoly.TopoEdges,\n    qbo::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    inters::Vector{Symbol},\n    indices::Union{Nothing, Vector{Vector{<:Integer}}},\n    lowcon::Union{Nothing, Vector{Float64}},\n    upcon::Union{Nothing, Vector{Float64}}\n)\n\n\nFunction fixing polygons vertices in order to avoid intersection and topography crossing, changing sign to the corresponding elements in the momentum array. This algorithm is in agreement with the mathematical properties of the Hamiltonian Dynamics.  \n\n\n\n\n\n","category":"function"},{"location":"geopoly/#Useful-functions","page":"GeoPoly","title":"Useful functions","text":"","category":"section"},{"location":"geopoly/","page":"GeoPoly","title":"GeoPoly","text":"MagGravPoly.GeoPoly.checkbodyindices\nMagGravPoly.GeoPoly.Inter2Segm\nMagGravPoly.GeoPoly.isInternal\nMagGravPoly.GeoPoly.checkmodelizdim\nMagGravPoly.GeoPoly.calcareapoly\nMagGravPoly.GeoPoly.calcareamanypoly","category":"page"},{"location":"geopoly/#MagGravPoly.GeoPoly.checkbodyindices","page":"GeoPoly","title":"MagGravPoly.GeoPoly.checkbodyindices","text":"checkbodyindices(\n    bodyindicesorg::Vector{<:Vector{<:Integer}},\n    verticesorg::AbstractMatrix{<:Real}\n) -> Tuple{Vector{<:Vector{<:Integer}}, Any}\n\n\nFunction to check all polygons' vertices and bodyindices in order to make sure that vertices in   common among polygons appear only once.\n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.Inter2Segm","page":"GeoPoly","title":"MagGravPoly.GeoPoly.Inter2Segm","text":"Inter2Segm(\n    P1x::Float64,\n    P1z::Float64,\n    P2x::Float64,\n    P2z::Float64,\n    P3x::Float64,\n    P3z::Float64,\n    P4x::Float64,\n    P4z::Float64\n) -> Union{Nothing, Matrix{Float64}}\n\n\nFunction to check if there is intersection beetween two segments, defined by their vertices. The output returns the (x,z) coordinates of the point in the case of intersection.\n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.isInternal","page":"GeoPoly","title":"MagGravPoly.GeoPoly.isInternal","text":"isInternal(\n    bo::MagGravPoly.GeoPoly.BodySegments2D,\n    px::Float64,\n    pz::Float64\n) -> Bool\n\n\nFunction to check if a point is internal to a polygon.\n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.checkmodelizdim","page":"GeoPoly","title":"MagGravPoly.GeoPoly.checkmodelizdim","text":"checkmodelizdim(\n    topo::MagGravPoly.GeoPoly.TopoEdges,\n    bo::Vector{MagGravPoly.GeoPoly.BodySegments2D},\n    perc::Real\n)\n\n\nFunction to check if the topography extends both righward and leftward beyond the outermost polygons by a user-defined percentage (> 25%).  \n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.calcareapoly","page":"GeoPoly","title":"MagGravPoly.GeoPoly.calcareapoly","text":"Calculate the area of a single polygon given a `BodySegments2D` structure.\nReturns the value of the area.\n\n\n\n\n\n","category":"function"},{"location":"geopoly/#MagGravPoly.GeoPoly.calcareamanypoly","page":"GeoPoly","title":"MagGravPoly.GeoPoly.calcareamanypoly","text":"Calculate area of a set of polygons given a `PolygBodies2D` structure.\nReturns a vector where each element is the area of one of the polygons.\n\n\n\n\n\n","category":"function"},{"location":"#MagGravPoly","page":"Home - MagGravPoly","title":"MagGravPoly","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Pages = [\"index.md\",\"geopoly.md\"]\nDepth = 3","category":"page"},{"location":"#User-Guide","page":"Home - MagGravPoly","title":"User Guide","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"MagGravPoly is a Julia package to perform magnetic and gravity anomaly calculations using a 2D or 2.75D parameterization in terms of polygons with uniform arbitrary magnetizations and density contrasts. It provides functions to 1) solve the forward problem, 2) calculate the gradient of a given misfit function and 3) create/manage polygonal structures through the internal sub-package GeoPoly. Such functions can be used to solve inverse problems both in the deterministic and probabilistic approach. In particular, this package provides some functions to solve inverse problems using the Hamiltonian Monte Carlo (HMC) method, as part of the GinvLab project (see the  InverseAlgos.jl package). Gradients are calculated using the technique of automatic differentiation. With this package it is also possible to perform joint magnetic and gravity forward and gradient calculations and hence solve joint inverse problems, see the tutorials below.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"The forward problem formulations for the magnetic case implemented in this package are the following:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"2D case: Talwani & Heirtzler (1962, 1964), Won & Bevis (1987) and revised Kravchinsky, Hnatyshin, Lysak, & Alemie (2019);\n2.75D case: revised Rasmussen & Pedersen (1979) and Campbell (1983).","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"The forward problem formulations for the gravity case implemented in this package are the following:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"2D case: Talwani, Worzel, & Landisman (1959), with background theory derived from the paper of Hubbert (1948);\n2.75D case:  Rasmussen & Pedersen (1979).","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"If you use this code for research or else, please cite the related papers:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Ghirotto, Zunino, Armadillo, & Mosegaard (2021). Magnetic Anomalies Caused by 2D Polygonal Structures with Uniform Arbitrary Polarization: new insights from analytical/numerical comparison among available algorithm formulations. Geophysical Research Letters, 48(7), e2020GL091732, https://doi.org/10.1029/2020GL091732.\nZunino, Ghirotto, Armadillo, & Fichtner (2022). Hamiltonian Monte Carlo probabilistic joint inversion of 2D (2.75D) gravity and magnetic data. Geophysical Research Letters,  49, e2022GL099789. https://doi.org/10.1029/2022GL099789.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Regarding solving the inverse problem with the HMC method, please see the following paper and check out the package InverseAlgos:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Zunino, Gebraad, Ghirotto, & Fichtner (2023). HMCLab: a framework for solving diverse geophysical inverse problems using the Hamiltonian Monte Carlo method. Geophysical Journal International, 235(3), 2979-2991. https://doi.org/10.1093/gji/ggad403.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"In addition, a tutorial about the use of forward formulations and the basic tuning strategies for HMC inversion is presented in detail in the below section.","category":"page"},{"location":"#Installation","page":"Home - MagGravPoly","title":"Installation","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"To install the package first enter into the package manager mode in Julia by typing \"]\" at the  REPL prompt and add the \"JuliaGeoph\" registry as","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"(@v1.9) pkg> registry add https://github.com/GinvLab/GinvLabRegistry","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Then add the package by simply issuing","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"(@v1.9) pkg> add MagGravPoly","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"The package will be automatically downloaded from the web and installed.","category":"page"},{"location":"#Theoretical-Background","page":"Home - MagGravPoly","title":"Theoretical Background","text":"","category":"section"},{"location":"#Forward-calculation","page":"Home - MagGravPoly","title":"Forward calculation","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"For a theoretical explanation, let us consider a three-dimensional non-magnetic and zero-density space in which a body infinitely extended in the y direction is immersed. ","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"The common aim of all formulations is the calculation of the total-field magnetic intensity response and vertical attraction of this body upon an observation point (x_0z_0) located along a profile aligned to the x direction (the positive z axis is assumed pointing downward).","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"The starting assumption is that our body can be considered as discretized by an  infinite number of elementary volumes with uniform magnetizazion and density contrast and infinitesimal dimensions dx, dy, dz.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Within this assumption, the magnetic and gravity fields associated to the body can be mathematically  expressed in terms of a line integral around its periphery, represented in two dimensions  as its polygonal cross-section (in red). (Image: )","category":"page"},{"location":"#Inverse-calculations","page":"Home - MagGravPoly","title":"Inverse calculations","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"See the related papers and examples for inverse calculations using the HMC strategy.","category":"page"},{"location":"#Tutorial-for-magnetic-calculations","page":"Home - MagGravPoly","title":"Tutorial for magnetic calculations","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"First load the module,","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"using MagGravPoly.MG2D\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"then define an array containing the location of the observation points, where the first column represents the x position and the second the  z position. Remark: z points downward! So the observations have a negative z in this case.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"# number of observations\nN=101\nxzobs = [LinRange(0.0,120.0,N) -1.0*ones(N)]\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"In order to describe the polygonal bodies, two objects need to be specifies: 1)  an array containing all the positions of the vertices (first column represents the x position and the second the  z position) and 2) a mapping relating each polygonal body to its vertices. The position of vertices must be specifyied in a counterclockwise order.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"# vertices of the poligonal bodies\nvertices  = [35.0 50.0;\n             65.0 50.0;\n             80.0 35.0;\n             65.0 20.0;\n             35.0 20.0;\n             20.0 35.0;\n             90.0 60.0;\n             95.0 40.0]\n\t\t\t \n# indices of vertices for the first polygon\nind1 = collect(1:6)\n# indices of vertices for the second polygon\nind2 = [2,7,8,3]\n# define the two bodies in term of indices\nbodyindices = [ind1,ind2]\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Now, we specify the magnetic properties for each of the polygonal bodies and the angle of the reference system with the north axis:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"# induced magnetization\nJind = MagnetizVector(mod=[4.9,3.5],Ideg=[0.0,0.0],Ddeg=[5.0,5.0])\n# remanent magnetization\nJrem = MagnetizVector(mod=[3.1,2.5],Ideg=[45.0,30.0],Ddeg=[0.0,10.0])\n\n# angle with the North axis\nnorthxax = 90.0\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Finally, construct the  poligonal body object by instantiating a MagPolygBodies2D structure. Here we can determine the type of forward calculation, i.e., 2D, 2.5D or 2.75D by specifying the variable ylatext. There are three cases:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"if ylatext=nothing then the polygonal bodies are considered to be extending laterally to infinity, hence a pure 2D forward calculation\nif ylatext is a single real number, then the forward computation is 2.5D, i.e., the polygonal bodies extend laterally on both sides by an amount specified by the value of ylatext\nif ylatext is a two-element vector, then the forward computation is 2.75D, i.e., the polygonal bodies extend laterally from ylatext[1] to ylatex[2] (with the condition ylatex[2]>ylatex[1]). ","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Here we choose to run a 2.75D forward computation:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"pbody = MagPolygBodies2D(bodyindices,vertices,Jind,Jrem,ylatext=[50.0,90.0])\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"At this point the magnetic field can be computed:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"tmag = tmagpolybodies2D(xzobs,northxax,pbody)","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"The output vector is the magnetic anomaly at each of the observation points specified above.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Now we can plot the results (e.g., using CairoMakie):","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"using CairoMakie\n\nfig = Figure()\n\nax1 = Axis(fig[1,1],title=\"Magnetic anomaly\",xlabel=\"x\",ylabel=\"mag. anom.\")\nscatter!(ax1,xzobs[:,1],tmag)\n\nax2 = Axis(fig[2,1],title=\"Polygonal bodies\",xlabel=\"x\",ylabel=\"z\")\nx1 = [pbody.geom.bo[1].ver1[:,1]...,pbody.geom.bo[1].ver2[end,1]]\ny1 = [pbody.geom.bo[1].ver1[:,2]...,pbody.geom.bo[1].ver2[end,2]]\nscatterlines!(ax2,x1,y1)\nx2 = [pbody.geom.bo[2].ver1[:,1]...,pbody.geom.bo[2].ver2[end,1]]\ny2 = [pbody.geom.bo[2].ver1[:,2]...,pbody.geom.bo[2].ver2[end,2]]\nscatterlines!(ax2,x2,y2)\nax2.yreversed=true\n\nlinkxaxes!(ax1,ax2)\n\nsave(\"images/mag.svg\",fig) # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"(Image: )","category":"page"},{"location":"#Tutorial-for-gravity-calculations","page":"Home - MagGravPoly","title":"Tutorial for gravity calculations","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"First load the module,","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"using MagGravPoly.MG2D\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"then define an array containing the location of the observation points, where the first column represents the x position and the second the  z position. Remark: z points downward! So the observations have a negative z in this case.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"# number of observations\nN=101\nxzobs = [LinRange(0.0,120.0,N) -1.0*ones(N)]\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"In order to describe the polygonal bodies, two objects need to be specifies: 1)  an array containing all the positions of the vertices (first column represents the x position and the second the  z position) and 2) a mapping relating each polygonal body to its vertices. The position of vertices must be specifyied in a counterclockwise order.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"# vertices of the poligonal bodies\nvertices  = [35.0 50.0;\n             65.0 50.0;\n             80.0 35.0;\n             65.0 20.0;\n             35.0 20.0;\n             20.0 35.0;\n             90.0 60.0;\n             95.0 40.0]\n\t\t\t \n# indices of vertices for the first polygon\nind1 = collect(1:6)\n# indices of vertices for the second polygon\nind2 = [2,7,8,3]\n# define the two bodies in term of indices\nbodyindices = [ind1,ind2]\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Now, we specify the density for each of the polygonal bodies","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"# two bodies in this case\nrho = [2000.0,3000.0]\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Finally, construct the  poligonal body object by instantiating a GravPolygBodies2D structure. Here we can determine the type of forward calculation, i.e., 2D, 2.5D or 2.75D by specifying the variable ylatext. There are three cases:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"if ylatext=nothing then the polygonal bodies are considered to be extending laterally to infinity, hence a pure 2D forward calculation\nif ylatext is a single real number, then the forward computation is 2.5D, i.e., the polygonal bodies extend laterally on both sides by an amount specified by the value of ylatext\nif ylatext is a two-element vector, then the forward computation is 2.75D, i.e., the polygonal bodies extend laterally from ylatext[1] to ylatex[2] (with the condition ylatex[2]>ylatex[1]). ","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Here we choose to run a 2.75D forward computation:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"pbody = GravPolygBodies2D(bodyindices,vertices,rho,ylatext=[50.0,90.0])\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"At this point the gravity field can be computed:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"tgrav = tgravpolybodies2D(xzobs,pbody)","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"The output vector is the gravity anomaly at each of the observation points specified above.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Now we can plot the results (e.g., using CairoMakie):","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"using CairoMakie\n\nfig = Figure()\n\nax1 = Axis(fig[1,1],title=\"Gravity anomaly\",xlabel=\"x\",ylabel=\"grav. anom.\")\nscatter!(ax1,xzobs[:,1],tgrav)\n\nax2 = Axis(fig[2,1],title=\"Polygonal bodies\",xlabel=\"x\",ylabel=\"z\")\nx1 = [pbody.geom.bo[1].ver1[:,1]...,pbody.geom.bo[1].ver2[end,1]]\ny1 = [pbody.geom.bo[1].ver1[:,2]...,pbody.geom.bo[1].ver2[end,2]]\nscatterlines!(ax2,x1,y1)\nx2 = [pbody.geom.bo[2].ver1[:,1]...,pbody.geom.bo[2].ver2[end,1]]\ny2 = [pbody.geom.bo[2].ver1[:,2]...,pbody.geom.bo[2].ver2[end,2]]\nscatterlines!(ax2,x2,y2)\nax2.yreversed=true\n\nlinkxaxes!(ax1,ax2)\n\nsave(\"images/grav.svg\",fig) # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"(Image: )","category":"page"},{"location":"#Tutorial-for-joint-mag-and-grav","page":"Home - MagGravPoly","title":"Tutorial for joint mag and grav","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"First load the modules,","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"using MagGravPoly.MG2D","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"then define 1) the angle between the Magnetic Field's North and the model profile, 2) an array containing the location of the observation points along it, where the first column represents the x position and the second the  z position. Remark: z points downward! So the observations have a negative z in this case.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"# angle with the North axis\nnorthxax = 90.0\n\n# number of observations\nN=101\nxzobs_mag = [LinRange(0.0,120.0,N) -1.0*ones(N)]\nxzobs_grav = copy(xzobs_mag)\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"In order to describe the polygonal bodies, two objects need to be specifies: 1)  an array containing all the positions of the vertices (first column represents the x position and the second the  z position) and 2) a mapping relating each polygonal body to its vertices. The position of vertices must be specifyied in a counterclockwise order.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"# vertices of the poligonal bodies\nvertices  = [35.0 50.0;\n             65.0 50.0;\n             80.0 35.0;\n             65.0 20.0;\n             35.0 20.0;\n             20.0 35.0;\n             90.0 60.0;\n             95.0 40.0]\n\t\t\t \n# indices of vertices for the first polygon\nind1 = collect(1:6)\n# indices of vertices for the second polygon\nind2 = [2,7,8,3]\n# define the two bodies in term of indices\nbodyindices = [ind1,ind2]\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Now, we specify the density and magnetization for each of the polygonal bodies","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"# two bodies in this case\n# densities\nrho = [2000.0,3000.0]\n# induced magnetizations\nJind = MagnetizVector(mod=[4.9,1.0],Ideg=[0.0,0.0],Ddeg=[5.0,5.0])\n# remanent magnetizations\nJrem = MagnetizVector(mod=[3.1,1.5],Ideg=[45.0,-45.0],Ddeg=[0.0,0.0])\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Finally, construct the poligonal body object by instantiating a JointPolygBodies2D structure. Here we can determine the type of forward calculation, i.e., 2D, 2.5D or 2.75D by specifying the variable ylatext. There are three cases:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"if ylatext=nothing then the polygonal bodies are considered to be extending laterally to infinity, hence a pure 2D forward calculation\nif ylatext is a single real number, then the forward computation is 2.5D, i.e., the polygonal bodies extend laterally on both sides by an amount specified by the value of ylatext\nif ylatext is a two-element vector, then the forward computation is 2.75D, i.e., the polygonal bodies extend laterally from ylatext[1] to ylatex[2] (with the condition ylatex[2]>ylatex[1]). ","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Here we choose to run a 2.75D forward computation:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"pbody = JointPolygBodies2D(bodyindices,vertices,Jind,Jrem,rho,ylatext=[50.0,90.0])\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"At this point the gravity and magnetic fields can be computed:","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"# compute the gravity anomaly and total field magnetic anomaly\ntgrav,tmag = tjointpolybodies2D(xzobs_grav,xzobs_mag,northxax,pbody)\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"The output vectors are the gravity and magnetic anomalies at each of the observation points specified above.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Alternatively, in the 2D case we could choose among other forward formulations implemented, specified as strings. Now we choose as forward types for the gravity and magnetic case \"wonbev\" and \"talwani_red\" respectively (see docs of MagGravPoly for details):","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"pbody = JointPolygBodies2D(bodyindices,vertices,Jind,Jrem,rho,ylatext=nothing)\nnothing # hide\n# type of forward algorithms of the gravity and magnetic case\nforwtype_grav = \"wonbev\"\nforwtype_mag = \"talwani_red\"\n# compute the gravity anomaly and total field magnetic anomaly \ntgrav,tmag = tjointpolybodies2Dgen(xzobs_grav,xzobs_mag,northxax,pbody,forwtype_grav,forwtype_mag)\nnothing # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"Now we can plot the results (e.g., using CairoMakie):","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"using CairoMakie\n\nfig = Figure()\n\nax1 = Axis(fig[1,1],title=\"Gravity anomaly\",xlabel=\"x\",ylabel=\"grav. anom.\")\nscatter!(ax1,xzobs_grav[:,1],tgrav)\n\nax2 = Axis(fig[2,1],title=\"Total-field magnetic anomaly\",xlabel=\"x\",ylabel=\"mag. anom.\")\nscatter!(ax2,xzobs_mag[:,1],tmag)\n\nax3 = Axis(fig[3,1],title=\"Polygonal bodies\",xlabel=\"x\",ylabel=\"z\")\nx1 = [pbody.geom.bo[1].ver1[:,1]...,pbody.geom.bo[1].ver2[end,1]]\ny1 = [pbody.geom.bo[1].ver1[:,2]...,pbody.geom.bo[1].ver2[end,2]]\nscatterlines!(ax3,x1,y1)\nx2 = [pbody.geom.bo[2].ver1[:,1]...,pbody.geom.bo[2].ver2[end,1]]\ny2 = [pbody.geom.bo[2].ver1[:,2]...,pbody.geom.bo[2].ver2[end,2]]\nscatterlines!(ax3,x2,y2)\nax3.yreversed=true\n\nlinkxaxes!(ax1,ax2,ax3)\n\nsave(\"images/jointgravmag.svg\",fig) # hide","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"(Image: )","category":"page"},{"location":"#Public-API","page":"Home - MagGravPoly","title":"Public API","text":"","category":"section"},{"location":"#Module","page":"Home - MagGravPoly","title":"Module","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"MagGravPoly","category":"page"},{"location":"#MagGravPoly","page":"Home - MagGravPoly","title":"MagGravPoly","text":"MagGravPoly\n\n\n\n\n\n","category":"module"},{"location":"#Data-structures","page":"Home - MagGravPoly","title":"Data structures","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"MG2D.MagPolygBodies2D\nMG2D.GravPolygBodies2D\nMG2D.JointPolygBodies2D","category":"page"},{"location":"#MagGravPoly.MG2D.MagPolygBodies2D","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.MagPolygBodies2D","text":"struct MagPolygBodies2D\n\nStructure containing a set of polygonal bodies (described by their segments and all vertices) along with their magnetizations (Induced + Remanent). To create an instance, input an array of vectors of indices    (of vertices) for each body and the array of all the vertices.\n\nFields\n\ngeom::MagGravPoly.GeoPoly.PolygBodies2D: structure defining the geometry of the bodies\nJind::MagGravPoly.MG2D.MagnetizVector: vector of induced magnetizations\nJrem::MagGravPoly.MG2D.MagnetizVector: vector of remnant magnetizations\nylatext::Union{Nothing, Vector{<:Real}}: [y1 y2] = lateral extension of the polygonal body. Tipycally y1 is negative since observations are at y=0.\n\n\n\n\n\n","category":"type"},{"location":"#MagGravPoly.MG2D.GravPolygBodies2D","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.GravPolygBodies2D","text":"struct GravPolygBodies2D\n\nStructure containing a set of polygonal bodies (described by their segments and all vertices) along with their densities. To create an instance, input an array of vectors of indices (of vertices) for each body and the array of all the vertices.\n\nFields\n\ngeom::MagGravPoly.GeoPoly.PolygBodies2D: structure defining the geometry of the bodies\nrho::Vector{<:Real}: vector of densities\nylatext::Union{Nothing, Vector{<:Real}}: [y1 y2] = lateral extension of the polygonal body. Tipycally y1 is negative since observations are at y=0.\n\n\n\n\n\n","category":"type"},{"location":"#MagGravPoly.MG2D.JointPolygBodies2D","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.JointPolygBodies2D","text":"struct JointPolygBodies2D\n\nStructure containing a set of polygonal bodies (described by their segments and all vertices) along with their magnetizations (Induced + Remanent) and densities. To create an instance, input an array of vectors of indices    (of vertices) for each body and the array of all the vertices.\n\nFields\n\ngeom::MagGravPoly.GeoPoly.PolygBodies2D: structure defining the geometry of the bodies\nJind::MagGravPoly.MG2D.MagnetizVector: vector of induced magnetizations\nJrem::MagGravPoly.MG2D.MagnetizVector: vector of remnant magnetizations\nrho::Vector{<:Real}: vector of densities\nylatext::Union{Nothing, Vector{<:Real}}: [y1 y2] = lateral extension of the polygonal body. Tipycally y1 is negative since observations are at y=0.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"warning: Warning\nVertices of the polygonal bodies must be provided  in counterclockwise order to the function JointPolygBodies2D in order to perform gravity and magnetic anomaly calculations.","category":"page"},{"location":"#Forward-functions","page":"Home - MagGravPoly","title":"Forward functions","text":"","category":"section"},{"location":"#Magnetics","page":"Home - MagGravPoly","title":"Magnetics","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"MG2D.tmagpolybodies2D\nMG2D.tmagpolybodies2Dgen","category":"page"},{"location":"#MagGravPoly.MG2D.tmagpolybodies2D","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.tmagpolybodies2D","text":"tmagpolybodies2D(\n    xzobs::Matrix{<:Real},\n    northxax::Real,\n    pbodies::MagGravPoly.MG2D.MagPolygBodies2D\n) -> Vector{<:Real}\n\n\nTotal magnetic field (2D or 2.75D) for a set of polygonal bodies defined by their corners. Takes into account both induced and remnant magnetization. 2D formulation based on Talwani & Heitzler (1964), the default algorithm in Mag2Dpoly package. 2.75D formulation based on Rasmussen & Pedersen (1979) and Campbell (1983).\n\n\n\n\n\n","category":"function"},{"location":"#MagGravPoly.MG2D.tmagpolybodies2Dgen","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.tmagpolybodies2Dgen","text":"tmagpolybodies2Dgen(\n    xzobs::Matrix{<:Real},\n    northxax::Real,\n    pbodies::MagGravPoly.MG2D.MagPolygBodies2D,\n    forwardtype::String\n) -> Vector{<:Real}\n\n\nTotal magnetic field (2D) for a set of polygonal bodies defined by their corners. Takes into account both induced and remnant magnetization. Generic version containing four different algorithm formulations forwardtype, passed as a string:\n\n\"talwani\"      –> Talwani & Heitzler (1964)\n\"talwani_red\"  –> Talwani & Heitzler (1964) rederived from Kravchinsky et al. (2019)\n\"krav\"         –> Kravchinsky et al. (2019) rectified by Ghirotto et al. (2021)\n\"wonbev\"       –> Won & Bevis (1987)\n\n\n\n\n\n","category":"function"},{"location":"#Gravity","page":"Home - MagGravPoly","title":"Gravity","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"MG2D.tgravpolybodies2D\nMG2D.tgravpolybodies2Dgen","category":"page"},{"location":"#MagGravPoly.MG2D.tgravpolybodies2D","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.tgravpolybodies2D","text":"tgravpolybodies2D(\n    xzobs::Matrix{<:Real},\n    pbodies::MagGravPoly.MG2D.GravPolygBodies2D\n) -> Vector{<:Real}\n\n\nVertical attraction (2D or 2.75D) for a set of polygonal bodies defined by their corners. 2D formulation based on Talwani et al. (1959) and Blakely (1995).  2.75D formulation based on Rasmussen & Pedersen (1979). \n\n\n\n\n\n","category":"function"},{"location":"#MagGravPoly.MG2D.tgravpolybodies2Dgen","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.tgravpolybodies2Dgen","text":"tgravpolybodies2Dgen(\n    xzobs::Matrix{<:Real},\n    pbodies::MagGravPoly.MG2D.GravPolygBodies2D,\n    forwardtype::String\n) -> Vector{<:Real}\n\n\nVertical attraction (2D) for a set of polygonal bodies defined by their corners. Generic version containing two different algorithm formulations forwardtype, passed as a string:\n\n\"talwani\"      –> Talwani et al. (1959)\n\"wonbev\"       –> Won & Bevis (1987)\n\n\n\n\n\n","category":"function"},{"location":"#Joint-mag-and-grav","page":"Home - MagGravPoly","title":"Joint mag and grav","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"MG2D.tjointpolybodies2D\nMG2D.tjointpolybodies2Dgen","category":"page"},{"location":"#MagGravPoly.MG2D.tjointpolybodies2D","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.tjointpolybodies2D","text":"tjointpolybodies2D(\n    grav_xzobs::Matrix{<:Real},\n    mag_xzobs::Matrix{<:Real},\n    northxax::Real,\n    pbodies::MagGravPoly.MG2D.JointPolygBodies2D\n) -> Tuple{Vector{<:Real}, Vector{<:Real}}\n\n\nFunction to return the vertical attraction & total magnetic field (2D or 2.75D) for a set of polygonal bodies defined by their corners. Takes into account both induced and remnant magnetization. 2D formulations based on Talwani et al. (1959), Talwani & Heitzler (1964) and Blakely (1995). 2.75D formulations based on Rasmussen & Pedersen (1979) and Campbell (1983).\n\n\n\n\n\n","category":"function"},{"location":"#MagGravPoly.MG2D.tjointpolybodies2Dgen","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.tjointpolybodies2Dgen","text":"tjointpolybodies2Dgen(\n    grav_xzobs::Matrix{<:Real},\n    mag_xzobs::Matrix{<:Real},\n    northxax::Real,\n    pbodies::MagGravPoly.MG2D.JointPolygBodies2D,\n    forwtype_grav::String,\n    forwtype_mag::String\n) -> Tuple{Vector{<:Real}, Vector{<:Real}}\n\n\nVertical attraction & Total magnetic field (2D or 2.75D) for a set of polygonal bodies defined by their corners. Takes into account both induced and remnant magnetization. Gravity calculation is based on two different algorithm formulations defined by forwtype_grav, passed as a string:\n\n\"talwani\"      –> Talwani et al. (1959)\n\"wonbev\"       –> Won & Bevis (1987)\n\nMagnetic calculation instead is based on four different algorithm formulations defined by forwtype_mag, passed as a string:\n\n\"talwani\"      –> Talwani & Heitzler (1964)\n\"talwani_red\"  –> Talwani & Heitzler (1964) rederived from Kravchinsky et al. (2019)\n\"krav\"         –> Kravchinsky et al. (2019) rectified by Ghirotto et al. (2021)\n\"wonbev\"       –> Won & Bevis (1987)\n\n\n\n\n\n","category":"function"},{"location":"#HMC-helper-functions","page":"Home - MagGravPoly","title":"HMC helper functions","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"MG2D.Mag2DpolyProb\nMG2D.Grav2DpolyProb\nMG2D.Joint2DpolyProb","category":"page"},{"location":"#MagGravPoly.MG2D.HMCMag2Dpoly.Mag2DpolyProb","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.HMCMag2Dpoly.Mag2DpolyProb","text":"Julia structure to define a magnetic problem for HMC. The users must indicate the method to compute misfit gradient by ADkind string, choosing among FWDdiff, REVdiffTAPE or REVdiffTAPEcomp.  For an explanation of the automatic differentiation method, the reader is invited to look at the documentation  relative to the Julia packages ForwardDiff and ReverseDiff. \n\n\n\n\n\n","category":"type"},{"location":"#MagGravPoly.MG2D.HMCGrav2Dpoly.Grav2DpolyProb","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.HMCGrav2Dpoly.Grav2DpolyProb","text":"Julia structure to define a gravity problem for HMC. The users must indicate the method to compute the misfit gradient by ADkind string, choosing among FWDdiff, REVdiffTAPE or REVdiffTAPEcomp.  For an explanation of the automatic differentiation method, the reader is invited to look at the documentation  relative to the Julia packages ForwardDiff and ReverseDiff. \n\n\n\n\n\n","category":"type"},{"location":"#MagGravPoly.MG2D.HMCJointMG2D.Joint2DpolyProb","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.HMCJointMG2D.Joint2DpolyProb","text":"Julia structure to define a joint magnetic and gravity problem for HMC.  The users must indicate the method to compute misfit gradient for both the magnetic and gravity problem by ADkindmag and ADkindgrav strings, respectively, choosing among FWDdiff, REVdiffTAPE or REVdiffTAPEcomp.  For an explanation of the automatic differentiation method, the reader is invited to look at the documentation  relative to the Julia packages ForwardDiff and ReverseDiff.\n\n\n\n\n\n","category":"type"},{"location":"#Misfit-structure-and-functions","page":"Home - MagGravPoly","title":"Misfit structure & functions","text":"","category":"section"},{"location":"#Magnetics-2","page":"Home - MagGravPoly","title":"Magnetics","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"MG2D.Mag2DPolyMisf\nMG2D.precalcADstuffmag\nMG2D.calcmisfmag\nMG2D.calc∇misfmag","category":"page"},{"location":"#MagGravPoly.MG2D.Mag2DPolyMisf","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.Mag2DPolyMisf","text":"Julia structure containing all data required for both misfit and gradient calculations. The whichpar Symbol indicates which paramters the user would like to invert for. It should be :all, :vertices or :magnetization.  \n\n\n\n\n\n","category":"type"},{"location":"#MagGravPoly.MG2D.precalcADstuffmag","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.precalcADstuffmag","text":"precalcADstuffmag(\n    magmisf::MagGravPoly.MG2D.Mag2DPolyMisf,\n    ADkind::String,\n    vecmodpar::AbstractArray\n) -> Union{Nothing, ForwardDiff.GradientConfig{T} where T<:(ForwardDiff.Tag{F} where F<:MagGravPoly.MG2D.Mag2DPolyMisf), ReverseDiff.CompiledTape{T} where T<:(ReverseDiff.GradientTape{F, I} where {F<:MagGravPoly.MG2D.Mag2DPolyMisf, I<:ReverseDiff.TrackedArray}), ReverseDiff.GradientTape{F, I} where {F<:MagGravPoly.MG2D.Mag2DPolyMisf, I<:ReverseDiff.TrackedArray}}\n\n\nPre-calculate some parameters before computing the gradient of the misfit using automatic differentiation.\n\n\n\n\n\n","category":"function"},{"location":"#MagGravPoly.MG2D.calcmisfmag","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.calcmisfmag","text":"calcmisfmag(\n    modpar::AbstractArray,\n    magmisf::MagGravPoly.MG2D.Mag2DPolyMisf\n) -> Any\n\n\nFunction to compute the value of the misfit functional with respect to the model parameters.\n\n\n\n\n\n","category":"function"},{"location":"#MagGravPoly.MG2D.calc∇misfmag","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.calc∇misfmag","text":"calc∇misfmag(\n    magmisf::MagGravPoly.MG2D.Mag2DPolyMisf,\n    modpar::AbstractArray,\n    ADkind::String,\n    autodiffstuff\n) -> Any\n\n\nFunction to compute the gradient of misfit with respect to the model parameters required for HMC inversions.  The gradient is computed by means of automatic differentiation using one of three different methods. The user must indicate the method by ADkind string, choosing among FWDdiff, REVdiffTAPE or REVdiffTAPEcomp.  For an explanation about the automatic differentiation method, the reader is invited to look at the documentation  relative to the Julia packages ForwardDiff and ReverseDiff.\n\n\n\n\n\n","category":"function"},{"location":"#Gravity-2","page":"Home - MagGravPoly","title":"Gravity","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"MG2D.Grav2DPolyMisf\nMG2D.precalcADstuffgrav\nMG2D.calcmisfgrav\nMG2D.calc∇misfgrav","category":"page"},{"location":"#MagGravPoly.MG2D.Grav2DPolyMisf","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.Grav2DPolyMisf","text":"bodyindices::Array{Vector{I}, 1} where I<:Integer\nxzobs::Matrix{F} where F<:Real\ntgravobs::Vector{F} where F<:Real\ninvcovmat::AbstractMatrix{F} where F<:Real\nwhichpar::Symbol\nallvert::Union{Nothing, Matrix{F}} where F<:Real\nrho::Union{Nothing, Vector{F}} where F<:Real\nylatext::Union{Nothing, Vector{F}} where F<:Real\n\nJulia structure containing all data required for both misfit and gradient calculations. The whichpar symbol indicates which paramters the user would like to invert for. It should be :all, :vertices or :density.  \n\n\n\n\n\n","category":"type"},{"location":"#MagGravPoly.MG2D.precalcADstuffgrav","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.precalcADstuffgrav","text":"precalcADstuffgrav(\n    gravmisf::MagGravPoly.MG2D.Grav2DPolyMisf,\n    ADkind::String,\n    vecmodpar::AbstractArray\n) -> Union{Nothing, ForwardDiff.GradientConfig{T} where T<:(ForwardDiff.Tag{F} where F<:MagGravPoly.MG2D.Grav2DPolyMisf), ReverseDiff.CompiledTape{T} where T<:(ReverseDiff.GradientTape{F, I} where {F<:MagGravPoly.MG2D.Grav2DPolyMisf, I<:ReverseDiff.TrackedArray}), ReverseDiff.GradientTape{F, I} where {F<:MagGravPoly.MG2D.Grav2DPolyMisf, I<:ReverseDiff.TrackedArray}}\n\n\nPre-calculate some parameters before computing the gradient of the misfit using automatic differentiation.\n\n\n\n\n\n","category":"function"},{"location":"#MagGravPoly.MG2D.calcmisfgrav","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.calcmisfgrav","text":"calcmisfgrav(\n    modpar::AbstractArray,\n    gravmisf::MagGravPoly.MG2D.Grav2DPolyMisf\n) -> Any\n\n\nFunction to compute the value of the misfit functional with respect to the model parameters.\n\n\n\n\n\n","category":"function"},{"location":"#MagGravPoly.MG2D.calc∇misfgrav","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.calc∇misfgrav","text":"calc∇misfgrav(\n    gravmisf::MagGravPoly.MG2D.Grav2DPolyMisf,\n    modpar::AbstractArray,\n    ADkind::String,\n    autodiffstuff\n) -> Any\n\n\nFunction to compute the gradient of the misfit with respect to the model parameters as required for HMC inversions.  The gradient is computed by means of automatic differentiation using one of three different methods. The user must indicate the method by ADkind string, choosing among FWDdiff, REVdiffTAPE or REVdiffTAPEcomp.  For an explanation about the automatic differentiation method, the reader is invited to look at the documentation  relative to the Julia packages ForwardDiff and ReverseDiff.  \n\n\n\n\n\n","category":"function"},{"location":"#Useful-functions-for-magnetics","page":"Home - MagGravPoly","title":"Useful functions for magnetics","text":"","category":"section"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"note: Note\nThese functions are not exported. To call them type MagGravPoly.MG2D before the name of the functions.","category":"page"},{"location":"","page":"Home - MagGravPoly","title":"Home - MagGravPoly","text":"MG2D.convert_H_to_B_nT\nMG2D.convert_B_nT_to_H\nMG2D.magcomp","category":"page"},{"location":"#MagGravPoly.MG2D.convert_H_to_B_nT","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.convert_H_to_B_nT","text":"convert_H_to_B_nT(H_Am::Real) -> Any\n\n\nConvert from the field H (A/m) to B (nT).\n\n\n\n\n\n","category":"function"},{"location":"#MagGravPoly.MG2D.convert_B_nT_to_H","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.convert_B_nT_to_H","text":"convert_B_nT_to_H(B_nT::Real) -> Any\n\n\nConvert from the field B (nT) to H (A/m).\n\n\n\n\n\n","category":"function"},{"location":"#MagGravPoly.MG2D.magcomp","page":"Home - MagGravPoly","title":"MagGravPoly.MG2D.magcomp","text":"magcomp(\n    modJind::Real,\n    Iind::Real,\n    Dind::Real,\n    modJrem::Real,\n    Irem::Real,\n    Drem::Real,\n    C::Real\n) -> Tuple{Any, Any, Any}\n\n\nVector addition of magnetic (remnant + induced) components.\n\n\n\n\n\n","category":"function"}]
}
